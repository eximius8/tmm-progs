(defun perokr (o1 o2 r1 r2 prisn / cosgam o1o2 niz gam rad);пересечение окружностей
                                              ;prisn = t верхняя точка пересечения 
                                              ;prisn = nil нижняя точка пересечения
  (if (> o1o2 (+ r1 r2)) (alert "\nОкружности не пересеклись!"))              ;;;;;
  (setq o1o2 (distance o1 o2))                                                ;;;;;
  (if                                                                         ;;;;;
    (> (cadr o1) (cadr o2))                                                   ;;;;;
      (progn                                                                  ;;;;;
        (setq niz o2                                                          ;;;;;
              rad r2                                                          ;;;;;
              o2 o1                                                           ;;;;;
              r2 r1                                                           ;;;;;
              o1 niz                                                          ;;;;;
              r1 rad)
      );                                                                      progn
  );                                                                             if
  (setq cosgam (/ (- (+ (* o1o2 o1o2) (* r1 r1)) (* r2 r2)) (* 2 o1o2 r1)))
  (setq gam (arccos cosgam))
  (if prisn
    (polar o1 (- (angle o1 o2) gam) r1)
    (polar o1 (+ (angle o1 o2) gam) r1)
  );                                                                       if prisn
);                                                                     defun perokr

;Пересечение 2-х окружностей заданных центром и радиусом, лежащих в одной плоскости
;----------------------------------------------------------------------------------
;Параметры:
;P1, R1 - ценр и радиус 1-й окружности
;P2, R2 - ценр и радиус 2-й окружности
;Возвращает список точек пересечения окружностей или nil если не пересекаются======
(defun circint (P1 R1 P2 R2 / A A1 CosA D $Dopusk)
  (setq D (distance P1 P2) A1 (angle P1 P2)
	$Dopusk 1e-8
  )
  (cond
    ((equal D (+ R1 R2) $Dopusk) (list (polar P1 A1 R1) (polar P1 A1 R1)))
    ((> D (+ R1 R2)) nil)
    (T
      (setq CosA (/ (- (+ (* R1 R1) (* D D)) (* R2 R2)) 2.0 R1 D)
            A (atan (sqrt (- 1 (* CosA CosA))) CosA)
      )
      (list (polar P1 (+ A1 A) R1) (polar P1 (- A1 A) R1))
    );end of T
  );end of cond
);end of defun

(defun dwgru (P1 P2 Pc R / A An D Ph)
;;;;;;;;;;           ;;; Пересечение прямой и окружности, лежащих в одной плоскости
;;;                                                      ;;; Математическое решение
;;;;;                                                                 ;;;Параметры:
                                                  ;;;P1, P2 — точки задающие прямую
                                                           ;;;Pc — центр окружности
                                                           ;;;R — радиус окружности
              ;;; Возвращает: Список точек пересечения или nil если не пересекаются
 (setq A (angle P1 P2)
       An (+ A (* 0.5 PI))
       Ph (inters P1 P2 Pc (polar Pc An 1000.0) nil)
       D (distance Ph Pc)
 )
 (cond                                                                            ;
  ((equal D R 1e-6) (list Ph Ph))                                                 ;
  ((> D R) (alert "\Мимо"))                                                       ;
  (T (setq D (sqrt (- (* R R) (* D D)))) (list (polar Ph A D) (polar Ph A (- D))));
 )                                                                                ;
);                         /|\Функции для плана механизма /|\                 dwgru
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;--------------=====================Находит точку пересчения двух векторов на планах============---------------
(defun peres (t1 t2 t3 polus konec)
;t1 t2 t3 - точки звеньев необходимо найти скорость точки t2 t1 - подвижная точка t3 - неподвижная
;konec - точка на плане скоростей обозначающая конец вектора скорости через который прохоид скорость vt2t1
;возвращает точку пересечения скоростей
  (inters polus (polar polus (- (angle t2 t3) (/ pi 2)) 100) (polar konec (- (angle t1 t2) (/ pi 2)) 100) konec nil)
);end of peres
;-----=================считает координаты точки на плане скоростей или ускорений подобную t3=====-------
(defun podob (t1 t2 t3 to1 to2 / ug1 otn)
  (setq
    ug1 (- (angle t3 t2) (angle t1 t2))
    otn (/ (distance t3 t2) (distance t1 t2))
  )
  (polar to2 (+ ug1 (angle to2 to1)) (* otn (distance to1 to2)))
)
;=======================================Для моментов=======================================
;==========================================================================================
;-=========================================================================================
;==========================================================================================
;|=========|;                                                              ;|============|;
;==========================================================================================

;------------================считает расстояние от точки ass до прямой заданной точками t1 t2===============-------------
(defun rastpr (ass t1 t2)
  (distance ass (inters t1 t2 ass (polar ass (+ (angle t1 t2) (/ pi 2)) 20) nil))
)
(defun rastpr2 (ass t1 t2)
  (atof (rtos (distance ass (inters t1 t2 ass (polar ass (+ (angle t1 t2) (/ pi 2)) 5) nil)) 2 1))
)
(defun clockwise-p (polus p1 p2)
;;;;;; Clockwise-p
;;;;;; Returns nil if p1 p2 and p3 are clockwise
  (> (sin (- (angle polus p2) (angle polus p1))) -1e-14)
)
;---------=========================Считает момент силы=========================----------
(defun moment (silad ts1 ts2 plus);sila - значение силы в Н t1, t2 точки силы plus - точка относительно которой считается момент
  (if (clockwise-p plus ts1 ts2)
    (* silad (rastpr plus ts1 ts2))
    (* silad (rastpr plus ts1 ts2) -1)
  );end of if
)
(defun moment2 (silad ts1 ts2 plus);sila - значение силы в Н t1, t2 точки силы plus - точка относительно которой считается момент
  (if (clockwise-p plus ts1 ts2)
    (* silad (rastpr2 plus ts1 ts2))
    (* silad (rastpr2 plus ts1 ts2) -1)
  );end of if
)
;=======================================Для моментов=======================================
;==========================================================================================
;-=========================================================================================
;==========================================================================================
;|=========|;                                                              ;|============|;
;==========================================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;конец раздела вспомогательных функций;;;;;;;;;;;;;;;;;;;;;;;;;
  
; Пересечение 2-х окружностей заданных центром и радиусом, лежащих в одной плоскости
;-------------------------------------------------------------------------
;Параметры:
;P1, R1 - ценр и радиус 1-й окружности
;P2, R2 - ценр и радиус 2-й окружности
; Возвращает список точек пересечения окружностей или nil если не пересекаются
(defun 2d_inters_circle (P1 R1 P2 R2 / A A1 CosA D $Dopusk)
  (setq D (distance P1 P2) A1 (angle P1 P2)
	$Dopusk 1e-6
  )
  (cond
    ((equal D (+ R1 R2) $Dopusk) (list (polar P1 A1 R1) (polar P1 A1 R1)))
    ((> D (+ R1 R2)) (alert "Окружности не пересекаются"))
    (T
      (setq CosA (/ (- (+ (* R1 R1) (* D D)) (* R2 R2)) 2.0 R1 D)
            A (atan (sqrt (- 1 (* CosA CosA))) CosA)
      ); setq
      (list (polar P1 (+ A1 A) R1) (polar P1 (- A1 A) R1))
    )
  ); cond
); defun

(defun cosinus (t1 t2 t3 t4)
    (cos (- (angle t1 t2)
	    (angle t3 t4)
	 )
    );_ cos
);_ defun

(load "tmm_excel.lsp")
(load "tmm_draw.lsp")
(load "tmm_trigon.lsp")
(load "tmm_flywheel.lsp")
(load "tmm_activex.lsp")
(load "tmm_semi.lsp")
(setq total_adress "c:\\tmm_different\\")
(setvar "DIMDEC" 0)